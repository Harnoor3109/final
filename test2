#include "xil_printf.h"
#include "stdint.h"

#define DELAY_UNIT    81
#define BTN           (*(volatile unsigned *)0x40030000)  // GPIO-3 4-bit, (btnR, btnL, btnD, btnU)
#define ANODES        (*(volatile uint32_t *)0x40006000)  // seven-segment anode control (active low, bottom 4 bits)
#define SEG           (*(volatile uint32_t *)0x40020000)  // seven-segment cathode patterns
#define LEDS          (*(volatile uint32_t *)0x40005000)  // 16 onboard LEDs
#define JXADC_CH6     (*(volatile uint16_t *)0x44a20258)  // ADC channel 6
#define JXADC_CH14    (*(volatile uint16_t *)0x44a20278)  // ADC channel 14

// simple millisecond delay
void delay_ms(unsigned t) {
    while (t--) {
        for (unsigned i = 0; i < 100; i++) {
            for (unsigned j = 0; j < DELAY_UNIT; j++) {
                __asm__ volatile ("nop");
            }
        }
    }
}

// rising-edge detector for the “up” button (BTN bit 0)
_Bool up_button_press() {
    static uint8_t prev = 0;
    uint8_t curr = BTN & 0x1;
    _Bool pressed = (curr && !prev);
    prev = curr;
    return pressed;
}

// sample the ADC N times and return duty cycle % (0–100)
int measure_duty_cycle(volatile uint16_t *adc_reg) {
    const int samples = 1000;
    int high_count = 0;
    for (int i = 0; i < samples; i++) {
        // scale raw 12-bit reading (0–4095) to 0–2400
        uint16_t v = ((*adc_reg >> 4) * 2400) / 4095;
        if (v > 1200) high_count++;
    }
    return (high_count * 100) / samples;
}

// light the 16 LEDs as a strength bar based on two coil duty cycles
void strength_meter(int c0, int c1) {
    if      (c0 <= 1 || c1 <= 13) LEDS = 0xFFFF;
    else if (c0 <= 2 || c1 <= 14) LEDS = 0x3FFF;
    else if (c0 <= 3 || c1 <= 15) LEDS = 0x07FF;
    else if (c0 <= 4 || c1 <= 16) LEDS = 0x007F;
    else if (c0 <= 5 || c1 <= 17) LEDS = 0x000F;
    else if (c0 <= 6 || c1 <= 18) LEDS = 0x0007;
    else if (c0 <= 7 || c1 <= 19) LEDS = 0x0003;
    else                          LEDS = 0x0000;
}

// draw one digit (0–3) with the given 8-bit segment pattern
void draw_digit(uint8_t digit, uint8_t pattern) {
    ANODES = 0xF;                        // turn all digits off
    SEG    = pattern;                   // output the segment bits
    ANODES = (~(1 << digit)) & 0xF;     // enable the one digit (active low)
    delay_ms(1);                        // brief hold for visibility
}

// refresh all four display positions in sequence
void refresh_display(uint8_t left, uint8_t mid, uint8_t right, uint8_t pos) {
    static const uint8_t sevenSegLUT[16] = {
        0x40, 0x79, 0x24, 0x30,
        0x19, 0x12, 0x02, 0x78,
        0x00, 0x10, 0x77, 0x7C,
        0x39, 0x5E, 0x79, 0x71
    };
    static const uint8_t pos_lut[4] = { 0x39, 0x38, 0x50, 0x00 };

    uint8_t patterns[4] = {
        sevenSegLUT[left  & 0x0F],
        sevenSegLUT[mid   & 0x0F],
        sevenSegLUT[right & 0x0F],
        pos_lut  [pos   & 0x03]
    };

    for (uint8_t d = 0; d < 4; d++) {
        draw_digit(d, patterns[d]);
    }
}

int main() {
    uint8_t left_ctr  = 0,
            mid_ctr   = 0,
            right_ctr = 0,
            pos       = 0;

    print("Start here!\n");

    while (1) {
        // 1) take 2 ADC measurements and update the LEDs
        int c0 = measure_duty_cycle(&JXADC_CH6);
        int c1 = measure_duty_cycle(&JXADC_CH14);
        strength_meter(c0, c1);

        // 2) over the next ~40 ms, repeatedly refresh the display
        //    and only increment counters when a clean button press occurs
        for (int i = 0; i < 10; i++) {
            refresh_display(left_ctr, mid_ctr, right_ctr, pos);
            if (up_button_press()) {
                if      (c0 <= 3)                             { left_ctr++;  pos = 0; }
                else if (c0 > 3 && c0 < 7 && c1 > 14 && c1 < 19) { mid_ctr++;   pos = 1; }
                else if (c1 <= 15)                            { right_ctr++; pos = 2; }
                else if (c0 >= 7 && c1 > 19)                  {               pos = 3; }
            }
        }
    }

    return 0;
}
